configfile: "config/config.yaml"

""" Eventual implementation of wine/docker use of convert.exe
rule raw_to_mzml:
	input:
		"data/raw/{timepoint}.RAW"
	output:
		"data/mzml/{timepoint}.mzML"
	script:
		script to run docker/wine env for msconvert.exe
"""

# make flat list of all MS datafiles
all_timepoint_files = []
for key in config["timepoints"]:
    for file in config[key]:
        all_timepoint_files.append(file)

# snakefile targets creation of library_info.csv and gzipping all .mzMLs
rule all:
    input:
        "resources/library_info/library_info.csv",
        expand("resources/mzml/{mzml}.gz", mzml=all_timepoint_files),


if config['polyfit_calibration']:
    rule read_imtbx:
        input:
            # .peaks.isotopes files must be made in windows, but only need to be made for undeuterated MS runs
            "resources/isotopes/{undeut_fn}.peaks.isotopes",
            config["names_and_seqs"],
        output:
            "resources/imtbx/{undeut_fn}_intermediate.csv",
            "results/plots/preprocessing/{undeut_fn}_original_mz.pdf",
            "results/plots/preprocessing/{undeut_fn}_adjusted_mz.pdf",
            "results/imtbx/{undeut_fn}_mz_calib_dict.pk"
        benchmark:
            "results/benchmarks/read_imtbx.{undeut_fn}.benchmark.txt"
        shell:
            "python workflow/scripts/HDX_LIMIT/preprocessing/imtbx_reader.py {input[0]} {input[1]} --out_path {output[0]} --original_mz_kde_path {output[1]} --adjusted_mz_kde_path {output[2]} --calibration_outpath {output[3]}"

else: 
    rule read_imtbx:
        input:
            # .peaks.isotopes files must be made in windows, but only need to be made for undeuterated MS runs
            "resources/isotopes/{undeut_fn}.peaks.isotopes",
            config["names_and_seqs"],
        output:
            "resources/imtbx/{undeut_fn}_intermediate.csv",
            "results/plots/preprocessing/{undeut_fn}_original_mz.pdf",
            "results/plots/preprocessing/{undeut_fn}_adjusted_mz.pdf"
        benchmark:
            "results/benchmarks/read_imtbx.{undeut_fn}.benchmark.txt"
        shell:
            "python workflow/scripts/HDX_LIMIT/preprocessing/imtbx_reader.py {input[0]} {input[1]} --out_path {output[0]} --original_mz_kde_path {output[1]} --adjusted_mz_kde_path {output[2]}"


rule gzip_mzmls:
    input:
        "resources/mzml/{mzml}",
    output:
        "resources/mzml/{mzml}.gz",
    benchmark:
        "results/benchmarks/gzip_mzml.{mzml}.benchmark.txt"
    shell:
        "python workflow/scripts/HDX_LIMIT/preprocessing/gzip_mzml.py {input} --out_path {output}"


rule make_ims_mz_tics:
    # calculates total ionic current of an MS run at each LC retention timepoint, to be used by make_master_list.py
    input:
        "resources/mzml/{mzml}",
    output:
        "resources/tics/{mzml}.ims.mz.tic",
    benchmark:
        "results/benchmarks/make_ims_mz_tics.{mzml}.benchmark.txt"
    shell:
        "python workflow/scripts/HDX_LIMIT/preprocessing/make_ims_mz_tics.py {input} --out_path {output}"


rule make_library_master_list:
    input:
        config["names_and_seqs"],
        "config/config.yaml",
        expand("resources/mzml/{mzml}", mzml=all_timepoint_files[0]),
        expand(
            "resources/imtbx/{undeut_fn}_intermediate.csv", undeut_fn=config[0]
        ),
        expand("resources/tics/{mzml}.ims.mz.tic", mzml=all_timepoint_files),

    output:
        "results/plots/preprocessing/stretched_times_plots.png",
        "resources/library_info/library_info.csv",
    benchmark:
        "results/benchmarks/make_library_master_list.benchmark.txt"

    run:
        tics = " ".join([fn for fn in input if '.tic' in fn])
        intermediates = " ".join([fn for fn in input if '_intermediate.csv' in fn])
        shell('''
            python workflow/scripts/HDX_LIMIT/preprocessing/make_library_master_list.py {input[0]} --timepoints {input[1]} --undeut_mzml {input[2]} --intermediates {intermediates} --tics {tics}  --plot {output[0]} --out_path {output[1]}
        ''')
